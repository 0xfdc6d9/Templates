# Nepenthe8's tricks

## 数学

### 二进制拆分
一个数$n$可以拆分为$x$个数字，分别为：
$$
    2^0,2^1,2^2,...,2^{k - 1},n-2^k+1, 其中k是满足n-2^k+1>0的最大整数
$$
满足使得这$x$个数可以组合得到任意小于等于$n$的正整数。

比如计算$5$的二进制拆分，首先计算得到$k$的取值，$k$是满足$5 - 2^k + 1 > 0$的最大整数，得到$k=2$，那么$5$的二进制拆分得到的数字为$2^0,2^1,5-2^2+1$，即$1,2,2$，容易验证这三个数可以组合得到任意小于等于$5$的正整数。

另外，$i$个$2$的次幂刚好可以组合出所有二进制下 $1$的个数为$i$ 的数。

[p-binary](https://codeforces.com/problemset/problem/1247/C)就用到了二进制拆分。

化简下式子可以得到
$$
    n-i*p=\sum_{1}^{i} 2^k，k是任意自然数
$$

那么我们可以枚举$i$，如果$n - i * p$的二进制表示下$1$的数量等于$i$，说明我们可以用$i$个$2$的幂次组合得到$n - i * p$。注意枚举$i$过程中$i$的上限，等式右边的最小值，当且仅当$k$全取$0$，那么等式右边的最小值为$i$，即如果$n - i * p < i$，可以break。


## 图论

### 打印路径的两种方法：

1. $pre[v] = u$，表示$v$的前驱为$u$，在更新了最小值之后紧接着更新$pre$数组。在打印结果时，从终点一路循环遍历到源点，将路过的节点依次储存在栈中。最后弹栈至空可以得到路径。

2. $path[i][j] = k$，表示$i$到j的路径为$i$先到$k$，再从$k$到$j$。在打印结果时也可以通过while循环实现。

   ~~~c++
   printf("Path: %d", x);
   while (x != y) {
       printf("-->%d", path[x][y]);
       x = path[x][y];
   }
   ~~~


## 杂项

### 签到的思路
1. 首先观察数据范围，确定是不是可以直接暴力/模拟/爆搜。
2. 如果没有很好的思路，手玩一下样例看看是否存在规律。
3. 连续区间，考虑双指针、前缀和、差分。
4. 求最优解问题，先寻找局部最优解，确定使用贪心或dp。
5. 遇到构造题，先确定最终的目标是什么，慢慢往目标上靠。（比如[Matrix Problem](https://ac.nowcoder.com/acm/contest/16092/M)，需要让构造出来的矩阵具有很强的连通性，想到像手一样的模型）
6. 逆向思维有时会大大降低实现难度。
7. 考虑抽屉原理可以起到剪枝的效果。（比如[Shortest Cycle](https://codeforces.com/contest/1206/problem/D)，抽屉原理使得n的规模缩减，从而可以使用floyd算法）